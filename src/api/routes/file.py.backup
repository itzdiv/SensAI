import os
import traceback
import uuid
from fastapi import APIRouter, HTTPException, File, UploadFile, Form
from fastapi.responses import FileResponse
from pydantic import BaseModel
# import boto3  # Commented out - using local storage only
# from botocore.exceptions import ClientError  # Commented out - using local storage only
from api.settings import settings
from api.utils.logging import logger
from api.models import (
    PresignedUrlRequest,
    PresignedUrlResponse,
    S3FetchPresignedUrlResponse,
)

router = APIRouter()


@router.put("/presigned-url/create", response_model=PresignedUrlResponse)
async def get_upload_presigned_url(
    request: PresignedUrlRequest,
) -> PresignedUrlResponse:
    # Using local storage only - no AWS/S3
    try:
        # Create the uploads directory if it doesn't exist
        os.makedirs(settings.local_upload_folder, exist_ok=True)
        
        # Generate a unique filename
        file_uuid = str(uuid.uuid4())
        file_extension = request.content_type.split("/")[1]
        filename = f"{file_uuid}.{file_extension}"
        
        # Return a local upload URL that points to our local upload endpoint
        local_upload_url = f"/file/upload-local"
        
        return {
            "presigned_url": local_upload_url,
            "file_key": filename,
            "file_uuid": file_uuid,
        }

    except Exception as e:
        logger.error(f"Error generating local upload URL: {str(e)}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Failed to generate upload URL")


@router.get("/presigned-url/get")
async def get_download_presigned_url(
    uuid: str,
    file_extension: str,
) -> S3FetchPresignedUrlResponse:
    # Using local storage only - no AWS/S3
    try:
        # Return a local file URL
        local_file_url = f"/uploads/{uuid}.{file_extension}"
        
        return {"url": local_file_url}

    except Exception as e:
        logger.error(f"Error generating local download URL: {str(e)}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Failed to generate download URL")


@router.post("/upload-local")
async def upload_file_locally(
    file: UploadFile = File(...), content_type: str = Form(...)
):
    try:
        # Create the folder if it doesn't exist
        os.makedirs(settings.local_upload_folder, exist_ok=True)

        # Generate a unique filename
        file_uuid = str(uuid.uuid4())
        file_extension = content_type.split("/")[1]
        filename = f"{file_uuid}.{file_extension}"
        file_path = os.path.join(settings.local_upload_folder, filename)

        # Save the file
        contents = await file.read()
        with open(file_path, "wb") as f:
            f.write(contents)

        # Generate the URL to access the file statically
        static_url = f"/uploads/{filename}"

        return {
            "file_key": filename,
            "file_path": file_path,
            "file_uuid": file_uuid,
            "static_url": static_url,
        }

    except Exception as e:
        logger.error(f"Error uploading file locally: {str(e)}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Failed to upload file locally")


@router.post("/upload-simple")
async def upload_file_simple(file: UploadFile = File(...)):
    """
    Simple file upload endpoint that doesn't require content_type in form data
    """
    try:
        # Create the folder if it doesn't exist
        os.makedirs(settings.local_upload_folder, exist_ok=True)

        # Generate a unique filename
        file_uuid = str(uuid.uuid4())
        file_extension = file.filename.split(".")[-1] if "." in file.filename else "bin"
        filename = f"{file_uuid}.{file_extension}"
        file_path = os.path.join(settings.local_upload_folder, filename)

        # Save the file
        contents = await file.read()
        with open(file_path, "wb") as f:
            f.write(contents)

        # Generate the URL to access the file statically
        static_url = f"/uploads/{filename}"

        return {
            "file_key": filename,
            "file_path": file_path,
            "file_uuid": file_uuid,
            "static_url": static_url,
            "content_type": file.content_type,
        }

    except Exception as e:
        logger.error(f"Error uploading file: {str(e)}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Failed to upload file")


@router.get("/download-local/")
async def download_file_locally(
    uuid: str,
    file_extension: str,
):
    try:
        file_path = os.path.join(
            settings.local_upload_folder, f"{uuid}.{file_extension}"
        )

        # Check if file exists
        if not os.path.exists(file_path):
            raise HTTPException(status_code=404, detail="File not found")

        # Return the file as a response
        return FileResponse(
            path=file_path,
            filename=f"{uuid}.{file_extension}",
            media_type="application/octet-stream",
        )

    except HTTPException:
        # Re-raise HTTP exceptions
        raise
    except Exception as e:
        logger.error(f"Error downloading file locally: {str(e)}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Failed to download file locally")


# Commented out AWS/S3 functions - using local storage only
# @router.put("/presigned-url/create-s3", response_model=PresignedUrlResponse)
# async def get_upload_presigned_url_s3(
#     request: PresignedUrlRequest,
# ) -> PresignedUrlResponse:
#     # Original S3 logic - commented out
#     pass

# @router.get("/presigned-url/get-s3")
# async def get_download_presigned_url_s3(
#     uuid: str,
#     file_extension: str,
# ) -> S3FetchPresignedUrlResponse:
#     # Original S3 logic - commented out
#     pass
